## 异步扣减库存
### 接口
1."/order/captcha":生成验证码接口，用于前端平滑流量；        
2."/order/token"：生成秒杀活动接口    
3."/order/create"：秒杀订单接口     


### Rockedmq事务型消息过程
![image](https://user-images.githubusercontent.com/52461848/170861787-5f1d0255-a333-4695-92a0-021775a3dfd0.png)

正常情况：    
1.生产者向MQ发送消息，此时是一个half消息    
2.MQ进行持久化，向生产者发送ACK确认消息接收成功    
3.生产者执行本地事务的逻辑    
4.生产者根据事务的执行状态（commit/rollback/unknown）发送给MQ    
异常情况：    
5.如果MQ超时未收到生产者根据事务的执行状态（步骤4），则进行消息回查
6.生产者收到回查消息，进行回查消息状态，检查本地事务的执行状态    
7.生成者根据回查的消息状态，发送给MQ，即重试步骤4    
8.提交消息，消费者进行消费

### 秒杀实现架构
![image](https://user-images.githubusercontent.com/52461848/168426934-9532f1da-f6de-4757-bfd3-dd61f126b10f.png)

## 超卖和高并发扣减库存
![image](https://user-images.githubusercontent.com/52461848/170870339-103d8496-8b16-458c-8697-d666066bf84d.png)
1.超卖检验：数据放入Redis中，每次扣减库存，都对Redis中的数据进行incryby 扣减，如果返回的数量大于0，说明库存够     
2.异步扣减库存，基于Rockedmq的事务型消息    
3.最终扣减数据库，热点怎么解决的呢？任务库使用订单号进行分库分表，这样针对同一个商品的不同订单会散列在任务库的不同库存，虽然还是数据库抗量，但已经消除了数据库热点。     
### 要点
1.热点防刷
由于redis 
实现方案：可以通过guava之类的框架，每10ms一个时间窗，每个时间窗进行计数，单台服务器超过计数进行限流。比如10ms超过2个就限流，那么一秒一台服务器就是200个，50台服务器一秒就可以卖出1万个货，自己根据实际情况调整阈值就可以。     
![image](https://user-images.githubusercontent.com/52461848/170871250-b82ed7e4-e329-4fdf-918c-dba0301ba313.png)

## 限流
