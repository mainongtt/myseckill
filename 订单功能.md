## 异步扣减库存
### 接口
1."/order/captcha":生成验证码接口，用于前端平滑流量；        
2."/order/token"：生成秒杀活动接口    
3."/order/create"：秒杀订单接口     


### Rockedmq事务型消息过程
![image](https://user-images.githubusercontent.com/52461848/170861787-5f1d0255-a333-4695-92a0-021775a3dfd0.png)

正常情况：    
1.生产者向MQ发送消息，此时是一个half消息    
2.MQ进行持久化，向生产者发送ACK确认消息接收成功    
3.生产者执行本地事务的逻辑    
4.生产者根据事务的执行状态（commit/rollback/unknown）发送给MQ    
异常情况：    
5.如果MQ超时未收到生产者根据事务的执行状态（步骤4），则进行消息回查
6.生产者收到回查消息，进行回查消息状态，检查本地事务的执行状态    
7.生成者根据回查的消息状态，发送给MQ，即重试步骤4    
8.提交消息，消费者进行消费

### 秒杀实现架构
![image](https://user-images.githubusercontent.com/52461848/168426934-9532f1da-f6de-4757-bfd3-dd61f126b10f.png)

## 超卖和高并发扣减库存
![image](https://user-images.githubusercontent.com/52461848/170870339-103d8496-8b16-458c-8697-d666066bf84d.png)
1.超卖检验：数据放入Redis中，每次扣减库存，都对Redis中的数据进行incryby 扣减，如果返回的数量大于0，说明库存够     
2.异步扣减库存，基于Rockedmq的事务型消息    
3.最终扣减数据库，热点怎么解决的呢？任务库使用订单号进行分库分表，这样针对同一个商品的不同订单会散列在任务库的不同库存，虽然还是数据库抗量，但已经消除了数据库热点。     
### 要点
1.热点防刷    
问题：Redis也是有瓶颈的，如果出现过热SKU就会打向Redis单片，会造成单片性能抖动。库存防刷有个前提是不能卡单的。可以定制设计JVM内毫秒级时间窗的限流，限流的目的是保护Redis,尽可能的不限流。限流的极端情况就是商品本来应该在一秒内卖完，但实际花了两秒，正常并不会发生延迟销售，之所以选择JVM是因为如果采用远端集中缓存限流，还未来得及收集数据就已经把Redis打死。          
实现方案：可以通过guava之类的框架，每10ms一个时间窗，每个时间窗进行计数，单台服务器超过计数进行限流。比如10ms超过2个就限流，那么一秒一台服务器就是200个，50台服务器一秒就可以卖出1万个货，自己根据实际情况调整阈值就可以。     
![image](https://user-images.githubusercontent.com/52461848/170871250-b82ed7e4-e329-4fdf-918c-dba0301ba313.png)

2.Redis扣减原理    
 - 扣减的幂等性保证->可以针对批量扣减命令增加一个防重码
 - 防止并发扣减后校验->为了防止并发扣减，需要对Redis的hincrby命令返回值是否为负数，来判断是否发生高并发超卖，如果扣减后的结果为负数，需要反向执行hincrby，把数据进行加回
 - 使用Pipeline,能尽量保证多条命令返回结果的完整性
## 限流
