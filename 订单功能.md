## 异步扣减库存
### 接口
1."/order/captcha":生成验证码接口，用于前端平滑流量；        
2."/order/token"：生成秒杀活动接口    
3."/order/create"：秒杀订单接口     


### Rockedmq事务型消息过程
![image](https://user-images.githubusercontent.com/52461848/170861787-5f1d0255-a333-4695-92a0-021775a3dfd0.png)

正常情况：    
1.生产者向MQ发送消息，此时是一个half消息    
2.MQ进行持久化，向生产者发送ACK确认消息接收成功    
3.生产者执行本地事务的逻辑    
4.生产者根据事务的执行状态（commit/rollback/unknown）发送给MQ    
异常情况：    
5.如果MQ超时未收到生产者根据事务的执行状态（步骤4），则进行消息回查
6.生产者收到回查消息，进行回查消息状态，检查本地事务的执行状态    
7.生成者根据回查的消息状态，发送给MQ，即重试步骤4    
8.提交消息，消费者进行消费

### 秒杀实现架构
![image](https://user-images.githubusercontent.com/52461848/168426934-9532f1da-f6de-4757-bfd3-dd61f126b10f.png)

## 超卖和高并发扣减库存
![image](https://user-images.githubusercontent.com/52461848/170870339-103d8496-8b16-458c-8697-d666066bf84d.png)
1.超卖检验：数据放入Redis中，每次扣减库存，都对Redis中的数据进行incryby 扣减，如果返回的数量大于0，说明库存够     
2.异步扣减库存，基于Rockedmq的事务型消息    
3.最终扣减数据库，热点怎么解决的呢？任务库使用订单号进行分库分表，这样针对同一个商品的不同订单会散列在任务库的不同库存，虽然还是数据库抗量，但已经消除了数据库热点。     
### 要点
1.热点防刷    
问题：Redis也是有瓶颈的，如果出现过热SKU就会打向Redis单片，会造成单片性能抖动。库存防刷有个前提是不能卡单的。可以定制设计JVM内毫秒级时间窗的限流，限流的目的是保护Redis,尽可能的不限流。限流的极端情况就是商品本来应该在一秒内卖完，但实际花了两秒，正常并不会发生延迟销售，之所以选择JVM是因为如果采用远端集中缓存限流，还未来得及收集数据就已经把Redis打死。          
实现方案：可以通过guava之类的框架，每10ms一个时间窗，每个时间窗进行计数，单台服务器超过计数进行限流。比如10ms超过2个就限流，那么一秒一台服务器就是200个，50台服务器一秒就可以卖出1万个货，自己根据实际情况调整阈值就可以。     
![image](https://user-images.githubusercontent.com/52461848/170871250-b82ed7e4-e329-4fdf-918c-dba0301ba313.png)

2.Redis扣减原理    
 - 扣减的幂等性保证->可以针对批量扣减命令增加一个防重码
 - 防止并发扣减后校验->为了防止并发扣减，需要对Redis的hincrby命令返回值是否为负数，来判断是否发生高并发超卖，如果扣减后的结果为负数，需要反向执行hincrby，把数据进行加回
 - 使用Pipeline,能尽量保证多条命令返回结果的完整性

3.任务引擎实现数据库的最终一致性    
    
3.1任务引擎的作用    
- 支持简单的流程编排，并保证至少成功一次
- 作为状态机的引擎出现，支持状态机的调度

3.2核心原理    
- 先把任务落库，通过数据库事务保证子任务拆分和父任务完成的事务一致性，对于任务库
- 使用分库分表，可以支撑水平扩展，通过设计分库字段和业务库字段不同，无数据热点。

3.3任务引擎的核心处理流程：    
![image](https://user-images.githubusercontent.com/52461848/170942404-98afc64b-b6a5-4a6d-b292-e36753c8a340.png)
- 调用提交任务，先把任务持久化到数据库，状态为定处理，保证这件事一定得到处理
- 异步线程调用外部处理过程，调用外部处理完成后，接收返回子任务列表。通过数据库事务把父任务状态设置为已经完成，子任务落库。并把子任务加入线程池
- 子任务调度执行，并重新把新子任务落库，如果没有子任务返回，则整个流程结束    
注意事项：    
- 异常解锁Worker来把长时间未处理完成的任务解锁，防止因为服务器重启，或线程池满造成的任务一直锁定无服务器执行
- 补漏Worker防止服务器重启造成的线程池任务未执行完成，补漏程序重新锁定，触发执行
## 限流
